## 兜底逻辑（Fallback Logic）设计原则

> 目标：在保证系统韧性和用户体验的前提下，通过**有边界的兜底逻辑**提升可靠性，而不是“悄悄吞错”。

---

### 1. 什么是兜底逻辑

- **定义**：当主路径失败或不可用时，为了保证系统“可用且可观测”，在**明确的业务前提下**提供备用策略（默认值、降级路径、回退渠道等）。
- **本质**：对不确定性（网络、外部依赖、用户输入、环境差异）的**受控处理策略**，而不是“出错了随便给个默认值”。
- **关键要求**：
  - 兜底是**显式设计的业务决策**，而不是临时补丁；
  - 每一次兜底触发，都应当是**可观测的事件**（日志/metrics/告警）；
  - 对用户体验兜底与数据/业务兜底要**严格区分**。

---

### 2. 典型适用场景（应该用）

以下场景使用兜底逻辑通常是合理且必要的：

#### 2.1 外部依赖不可靠时

- 典型对象：第三方 API、支付网关、邮件/短信服务、外部爬虫、LLM 服务等。
- 原则：
  - 主路径失败 → 使用缓存、降级实现或“稍后重试”队列；
  - 必须记录失败原因（错误码、请求参数、关联 ID）。

示例（伪代码）：

```python
try:
    response = external_api.get_data()
    data = response.json()
except (ApiError, TimeoutError, ConnectionError) as e:
    log_warning("external_api_failed", error=e)
    data = cache.get("fallback_data") or get_default_data()
```

#### 2.2 用户输入与数据清洗

- 典型对象：表单字段、查询参数、第三方回调用到的可选字段。
- 适合兜底的点：
  - 空值处理（`null/undefined` → 默认值）；
  - 轻度的类型转换（字符串数字 → number）；
  - 安全范围裁剪（例如限制在 0–100 之间）。
- 注意：**不能用兜底绕过验证规则**，例如必填字段缺失时“随便填一个默认邮箱”。

示例：

```javascript
function processUserInput(input) {
  const value = input?.trim() || 'default';
  const number = Number.parseInt(value, 10) || 0;
  return Math.max(0, Math.min(number, 100));
}
```

#### 2.3 配置管理与环境差异

- 典型对象：环境变量、配置文件、A/B 开关、本地化资源。
- 兜底链路应是**有序且有限**的，例如：
  - 环境变量 → 配置文件 → 编译期默认值；
  - 当前语言包缺失 → 回退到默认语言。

示例：

```java
public String getDatabaseUrl() {
    return System.getenv("DB_URL") != null
        ? System.getenv("DB_URL")
        : properties.getProperty("db.url", "localhost:5432/app");
}
```

#### 2.4 功能降级（Graceful Degradation）

- 典型对象：高级特性、非核心增强功能（高阶推荐、复杂报表、实时推送等）。
- 原则：
  - 业务核心不依赖这些特性，失败时可回退；
  - 降级路径对用户透明且有合理文案提示。

示例：

```python
async def process_payment(order):
    try:
        result = await premium_gateway.charge(order)
    except PaymentError as e:
        log_warning("premium_gateway_failed", error=e)
        result = await basic_gateway.process(order)
    except Exception as e:
        log_error("payment_fallback_exhausted", error=e)
        result = {"status": "pending", "message": "请稍后重试"}
    return result
```

#### 2.5 缓存策略与读路径优化

- 典型对象：多级缓存（本地内存、Redis、数据库）。
- 合理模式：
  - 内存缓存 → 分布式缓存 → 最终数据源；
  - 读失败���不修改数据源，写失败必须显式失败或进入重试队列。

示例：

```javascript
class DataService {
  async getData(key) {
    let data = this.memoryCache.get(key);
    if (!data) {
      data = await this.redisCache.get(key);
    }
    if (!data) {
      data = await this.fetchFromDatabase(key);
      this.setCache(key, data);
    }
    return data;
  }
}
```

---

### 3. 不应使用或慎用兜底的场景

以下场景更适合使用 **fail fast + 明确错误**，而不是兜底：

1. **核心业务逻辑与关键规则校验**
   - 订单扣款、库存变更、额度修改、权限授予等；
   - 如果出现异常，应直接失败并留下可追踪的错误，而不是“假装成功”。

2. **数据一致性与账务相关逻辑**
   - 账单/流水、资产/积分、合约状态等；
   - 任何自动默认值都可能导致账实不符，兜底通常只能用在“只读展示层”，不能写库。

3. **开发/测试阶段的行为**
   - 在本地/测试环境中优先暴露问题（抛异常、断言失败）；
   - 不要为了“看起来能跑”提前加一层兜底，否则问题被掩盖到后期才暴露。

4. **安全、合规与权限校验**
   - 鉴权失败绝不能“兜底为 guest 权限继续执行”；
   - 合规性检查失败应立即阻断流程，并要求人工介入或更严格审计。

---

### 4. 兜底设计的关键要点

#### 4.1 兜底是显式的业务决策

- 每一个兜底分支都应该能回答三个问题：
  1. 为什么在这里允许降级或使用默认值？
  2. 对用户/数据的影响范围是什么？
  3. 出现该情况的频率预期是多少（偶发 / 常态）？
- 如果这三个问题答不清，多半说明兜底设计本身是值得怀疑的。

#### 4.2 必须具备良好的可观测性

- 每次进入兜底分支，至少要：
  - 记录结构化日志（错误类型、上下文、trace ID）；
  - 为关键兜底路径增加 metrics（如 `fallback_used_total`）；
  - 对超阈值场景配置告警（例如某类兜底 5 分钟内触发次数过多）。
- 目标：兜底是“有痕迹的异常”，而不是“静默吞错”。

#### 4.3 区分“用户体验兜底”与“领域数据兜底”

- **用户体验兜底**：
  - 如：i18n key 缺失时展示英文文案、头像加载失败时展示默认头像等；
  - 可以相对激进，只要不影响核心业务。
- **领域数据兜底**：
  - 如：计费、额度、权限、合约状态；
  - 应极度谨慎，多数情况下宁可报错、阻断流程，也不要自动假设一个“看起来合理”的值。

#### 4.4 保持兜底策略简单透明（KISS/YAGNI）

- 不要设计过于复杂、层级过多的兜底链：
  - 层级多 → 调试困难 → 容易形成“黑盒”，新同学难以理解；
  - 遵循 YAGNI：只实现当前确实需要的降级路径。
- 建议：
  - 单条调用链兜底层级控制在 2–3 级之内；
  - 共用兜底模式抽成小函数或策略对象，避免重复实现。

#### 4.5 明确兜底终点：最终失败也要可控

- 即使有多级兜底，仍然要考虑**所有策略都失败**时的行为：
  - 向上抛出一个语义明确的错误（如 `FallbackExhaustedError`）；
  - 保证上层可以据此做出统一处理（如展示错误页、录入人工处理队列）。

伪代码示例：

```python
def intelligent_fallback(primary, *fallbacks):
    errors = []
    try:
        return primary()
    except Exception as e:
        errors.append(e)
    for i, fb in enumerate(fallbacks, start=1):
        try:
            logger.warning("使用第%s级兜底策略", i)
            return fb()
        except Exception as e:
            errors.append(e)
    raise FallbackExhaustedError(errors)
```

---

### 5. 团队协作与 Code Review 建议

- 在 Code Review 中，对兜底逻辑重点检查：
  - 是否属于“合适的兜底场景”（见第 2 节）；
  - 是否错误地兜底了核心业务逻辑或数据一致性环节；
  - 是否有充分日志与监控，方便排查；
  - 文案是否清晰，避免误导用户（特别是付款、权限、数据丢失相关提示）。
- 对于“只是为了不报错而加的默认值”，应优先要求改成：
  - 明确的异常抛出；
  - 或受控的业务降级流程（如进入 pending 状态 + 人工处理）。

---

### 6. 业务兜底 vs 技术兜底清单（项目内约定）

为方便新同学快速判断哪些兜底是“刻意的业务决策”，哪些是“实现层策略”，在本项目中约定：

- **业务兜底（不轻易改动）**：
  - `resolveCurrentPlan`（`src/domain/plan/resolve-current-plan.ts`）：
    - “无订阅 → free plan” 是产品决策：未购买任何付费计划且非终身会员时，视为使用免费计划；
    - 若存在订阅但无法匹配到价格（配置缺失），`currentPlan` 返回 `null`，由上层 UI 决定如何显示，不会强行假定某个 plan。
  - Credits 发放策略（`src/credits/services/credit-ledger-service.ts` + `PlanCreditsPolicy`）：
    - 注册赠送 / 月度免费额度：policy 无规则时静默不发放，并记录日志（视为“该计划没有这类权益”）；
    - 订阅续费 / 终身权益：policy 无规则视为配置错误，日志 + `CreditsPlanPolicyMissingError` fail fast，不再静默跳过。
  - AI 文本分析结构化输出（`content-analyzer.ts`）：
    - Prompt 明确约定缺定价 → `"Not specified"`、缺 features/useCases → 空数组等，是约定的输出契约，避免前端因字段缺失崩溃。

- **技术兜底（可随着基础设施演进调整）**：
  - Firecrawl 配置（`scraper.ts` + `web-content-config.server.ts`）：
    - 缺少 API key 时，通过 `WebContentAnalyzerError(SERVICE_UNAVAILABLE)` 阻断分析，并记录日志；
    - 是否允许在某些环境下完全关闭该特性，可以依据部署需求调整，但始终保持“显式错误 + 可观测”。
  - Rate Limit 基础设施（`src/lib/server/rate-limit.ts`）：
    - dev/test 环境允许 in-memory fallback，便于本地开发与测试；
    - 非 dev/test 环境默认要求 Redis 配置齐全，缺失时记录错误日志并 fail fast，不允许静默退化为单实例限流。
  - 前端 AI 错误 UI（`useAiErrorUi` + `useWebContentAnalyzer` / `useImageGeneration`）：
    - 所有 AI 文本/图片错误 toast 统一走 `useAiErrorUi`，避免在组件中散落 `if (code === ...)`；
    - 具体页面可根据 `code` / `context.source` 再做细化 UI 引导，但不应绕开统一 hook 自行 toast。

### 7. 总结

- 兜底逻辑的价值在于：在**不可靠的世界里，让系统尽量可靠**，同时避免把真实问题藏起来。
- 高质量的兜底必须满足三点：
  1. **边界清晰**：只在适合兜底的地方兜底；
  2. **行为可观测**：触发兜底时能被监控与追踪；
  3. **决策可解释**：业务/产品可以理解并接受该降级行为的后果。
- 在此基础上，再结合同一项目中的 logging、错误码体系、监控平台，才能形成真正可演进、可维护的可靠性策略。
