错误码 & 文案兜底层
src/lib/domain-error-utils.ts (line 1)

作用：根据 code → i18n key 映射，同时提供 fallbackMessage。
行为：
无 code 时直接使用 fallbackMessage；
有 code 且有 translator 时，优先翻译 key；
无 translator 时使用预定义 fallback，否则回退到 fallbackMessage。
评估：
完全符合“用户体验兜底”原则：兜底发生在 UI 文案层，不影响领域数据或控制流；
兜底行为是显式设计的（定义在 DOMAIN_ERROR_MESSAGES 中），不存在“随便给默认”的情况。
建议：
可以视需要在文档中标注“新增 DomainError code 时必须在此注册，否则会退回 genericfallback”，但逻辑本身是健康的。

src/hooks/use-ai-error-ui.ts (line 1) 与 src/hooks/use-credits-error-ui.ts (line 1)

作用：将 DomainError/Envelope 映射到 toast + 跳转行为。
行为：
AI：将 code 映射为统一文案与 toast level，并在未知/无 code 时使用 fallback 文案。
Credits：为特定 code（未登录、余额不足）提供专门行为，其余走 fallback。
评估：
兜底完全局限在“错误展示体验”层，有明确默认文案，且不会篡改业务状态；
严格符合原则中“用户体验兜底可以更激进”的要求。
建议：
可以在错误日志层（例如未来的 logError 调用）增加记录 code / source（text/image/credits），方便观察兜底触发频率；目前 UI 层兜底本身设计合理。

AI 文本分析链路
src/ai/text/utils/error-handling.ts (line 1)

作用：将底层 Error 归类为 WebContentAnalyzerError，并提供 withRetry 兜底策略。
行为：
对网络/timeout/scraping/analysis/rate-limit/auth/service-unavailable 等关键词进行分类；
未识别的错误统一映射为 AI_CONTENT_UNKNOWN_ERROR，附带 retryable flag；
withRetry 根据 retryable 与配置的重试次数做指数退避。
评估：
兜底适用场景：外部服务调用 + 网络不确定性，完全符合设计原则中的“应该兜底”类别；
兜底终点清晰：重试多次仍失败则抛出语义明确的 WebContentAnalyzerError，不会悄悄吞错。
建议：
如后续接入更多 AI 或 HTTP client，可以考虑在这里集中扩展 error 分类，继续维持“所有入口都归一到 WebContentAnalyzerError”的策略。
src/ai/text/utils/analyze-content/content-analyzer.ts (line 50)

作用：生成结构化分析结果，并对上游错误做按类型兜底。
行为：
在 analyzeContent 内部进一步识别 rate-limit/timeout 关键词并抛出特定 WebContentAnalyzerError；
其它错误交给 classifyError；
Prompt 里对 struct 字段给出明确缺省：pricing 为 "Not specified"、features/useCases 为空数组、title/description 要基于实际内容。
评估：
兜底内容仅限于“结构化输出的字段完整性 + 更友好的错误类型”，并未篡改业务语义；
Prompt 级兜底保证 schema 校验不会因缺字段导致 runtime error，是合理的“结构兜底”。
建议：
若未来扩展分析字段，需在 schema + Prompt 中同步定义缺省规则，以保持“报错少、结构稳定”的特性。

src/ai/text/utils/analyze-content/scraper.ts (line 1) 与 web-content-config.*

作用：Firecrawl 抓取网页 + 内容截断兜底。
行为：
truncateContent：
优先尝试句子/段落边界截断，不符合条件时回退到基于字符数的简单截断；
截断点不足够“完整”时再回退到最后一个完整单词。
scrapeWebpage：
若 markdown 内容为空，抛出 WebContentAnalyzerError(SCRAPING)；
外部错误交给 classifyError。
评估：
截断兜底非常 KISS：专注在“保证长度合法 + 尽量不破坏句子”，属于典型的“非关键业务、用户体验优化”场景，可放心兜底；
对“无内容”的场景选择抛错而不是给默认内容，符合“核心业务不做假数据兜底”的原则。
轻微风险点：
src/ai/text/utils/web-content-config.server.ts (line 1) 中 getFirecrawlApiKey() 可能返回 null，但 getFirecrawlClient() 仍然会创建 new Firecrawl({ apiKey: null })，实际兜底行为依赖 Firecrawl SDK 内部错误处理；
虽然后续 classifyError 大概率能把错误归为 SCRAPING/NETWORK，但这是“隐式兜底”。
建议：
在 getFirecrawlClient() 里显式检查 apiKey：
若缺失，抛出 WebContentAnalyzerError(SERVICE_UNAVAILABLE, ...)；
或在更上游用 validateFirecrawlConfig() 决定是否完全关闭该功能。
这样兜底逻辑就从“SDK 内部行为”变成“显式业务决策 + 可观测”。

AI 图片生成链路
src/lib/server/usecases/generate-image-with-credits.ts (line 1)
作用：统一处理“计费 + 图片生成 + 错误 code 映射”。
兜底行为：
请求参数校验失败：直接返回 success: false + AI_IMAGE_INVALID_PARAMS；
provider 返回结构不合法：返回 AI_IMAGE_INVALID_RESPONSE，retryable: true；
调用超时：AI_IMAGE_TIMEOUT，retryable: true；
其它错误：AI_IMAGE_PROVIDER_ERROR，retryable: true。
评估：
兜底集中在“外部模型调用 + provider 行为不确定”这一层，是典型的可兜底场景；
对参数非法选择直接 fail fast（而不是兜底），符合“核心业务不要兜底”的原则；
全程通过 getLogger 记录关键事件和错误，满足“可观测性”要求。
建议：
已经有较完善的兜底矩阵（INVALID_PARAMS / INVALID_RESPONSE / TIMEOUT / PROVIDER_ERROR），可以在文档或错误指南中补一张对照表，帮助前端/运营理解不同错误的含义。

Plan & Credits 相关兜底
src/domain/plan/resolve-current-plan.ts (line 1)

行为：
过滤 disabled 的 plan；
若 isLifetimeMember，优先返回 lifetimePlan ?? null；
若有 subscription，则按 priceId 匹配对应 plan，找不到时 currentPlan: null, subscription: subscription；
既非终身也无 subscription 时，回退为 freePlan。
评估：
这是一个典型“业务显式决策型”兜底：
“没有订阅 → 算 free plan”是产品规则，而不是“为了不报错随便给一个”；
找不到匹配 plan 时返回 currentPlan: null，不做默认映射，避免错误收费。
建议：
若后续有“必须总有一个当前 plan”的 UI，可在 UI 层兜底（例如展示“Free”），不要在 domain 层强行指定默认 plan。
src/credits/config.ts (line 1)

行为：
对配置字段使用 ?? 默认值（如 amount ?? 0），并通过 enabled && amount > 0 决定是否真正启用；
缺 expireDays 时不自动填默认天数，而是保留 undefined。
评估：
这是“配置解析层”的数据兜底，用于避免 undefined 导致 runtime 错误；
是否启用 credits 始终由配置显式控制，未出现“为凑数随便给积分”的行为。
建议：
无明显问题；如引入全局 PlanCreditsPolicy 文档化，可以把“0 amount 即禁用”作为契约写清楚。
src/credits/services/credit-ledger-service.ts (line 1)

行为：
addRegisterGiftCredits：已发放过则直接 return；policy 无规则也直接 return；
addMonthlyFreeCredits / addSubscriptionCredits / addLifetimeMonthlyCredits：
policy 无规则时 return；
已存在对应 period 的交易时 return；
有规则则按 rule 填充 payload。
评估：
“已发放则 return”是典型幂等保护，属于健康兜底；
“policy 无规则时静默 return”属于“业务层兜底”， 如果这是产品层面的显式决策（某些 plan 本来就无对应权益），没问题； 但如果是配置漏配，就会变为“静默吞权益”的隐性问题。
建议（这里是一个值得关注的点）：
维持当前行为，但增加可观测性：
policy 无规则时，记录 creditsServiceLogger.info/warn，带上 planId/priceId 和 creditType；
optional：为“policy 无规则”增加 metrics（如 credits_missing_policy_total）。
这样符合原则中的“兜底必须可观测”，避免运营难以发现某些 plan 没有发积分的情况。

配置 / 环境与日志兜底
src/env/server.ts (line 1)

行为：
对可选字符串使用 .optional().transform(...) 将空字符串归一为 undefined；
对某些布尔/telemetry 字段给出默认值；
必需字段校验失败时直接抛错中止启动。
评估：
配置兜底仅用于“把不合法但常见的输入形式归一”（空字符串），不会给出假配置；
对 DATABASE_URL 等关键信息采用 fail fast，是正确做法。
src/ai/text/utils/web-content-config.server.ts (line 1)

行为：
validateFirecrawlConfig 在缺少 API key 时 console.warn 并返回 false，相当于“功能不可用但不崩溃”。
评估：
这是“配置自检 + 功能可用性兜底”，比较合理；
但目前实际调用点不明显——如果调用方没根据 result 来禁用功能，就会退回前面提到的“隐式由 SDK 报错”的路径。
建议：
在真实入口（如某个初始化或 health-check）中使用 validateFirecrawlConfig，并在 UI 或 ADMIN 面板中标明“该能力不可用”；
这样避免用户点击后才在运行时触发一连串兜底/报错。
src/lib/client-logger.ts (line 1)

行为：
shouldLog 关闭时，所有日志方法降级为 noop；
控制台不存在时也直接 return。
评估：
这是典型“用户体验/性能”层面的兜底：关闭日志不会改变业务行为；
符合原则中“可选特性可以降级”的要求。
