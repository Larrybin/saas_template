## 任务：结构化代码审核

### 背景
- 目标：针对整个 SaaS Template 仓库输出正式的架构/性能/安全/可维护性审计报告。
- 约束：遵循 Next.js/TypeScript 规范；提供结构化章节+表格；结合静态分析结果。

### 执行计划
1. **文档基线梳理**  
   - 阅读 `README.md`、`AGENTS.md`、`docs/*.md`，记录模块划分、日志/错误模型与质量门。
2. **静态分析采样**  
   - 运行 `pnpm lint`、`npx tsc --noEmit` 作为健康度基准，若有告警则归档证据。
3. **模块矩阵巡检**  
   - 依次浏览 `src/app`, `components`, `lib`, `credits`, `payment`, `storage` 等目录，按性能/安全/可维护性记录发现与文件行号。
4. **关键流程深挖**  
   - 额度消费链路（组件 → hooks → actions → domain）  
   - AI 内容分析（前端 hook → API route → use case → domain）  
   - 为每条链路绘制边界与潜在瓶颈/缺陷。
5. **报告整合**  
   - 输出执行摘要、静态分析结果、模块×维度表格，以及关键流程发现与优先级建议。

### 实际产出与结论

1. **架构/安全审核要点**
   - `src/app/api/storage/upload/route.ts`：补全鉴权、速率限制、Content-Type 检查及上传目录白名单，所有写入统一追加 `userId`，避免匿名批量上传与目录穿越。
   - `src/lib/safe-action.ts` / `src/lib/server/api-auth.ts`：封禁用户现已在 safe-action 与 API 鉴权层直接被阻断（`AUTH_BANNED`），日志与文案统一，封禁状态生效。
   - `src/credits/services/credit-ledger-service.ts`：移除 `getUserCredits` / `updateUserCredits` 的吞错逻辑，DomainError 直通调用方，避免余额被误写为 0。
   - `src/components/devtools/consume-credits-card.tsx`：标记为仅限内部使用组件，需要在生产构建阶段剔除（已列为整改项）。
   - 支付/积分/AI Use Case 结构边界清晰，DomainError + 日志链路可追踪，重点风险集中在未加固的入口层。

2. **静态分析**
   - `pnpm lint`（Biome）与 `npx tsc --noEmit` 均已执行完成，最后一次运行时间：2025-11-23 23:43（详见终端日志）。当前无未解决的 lint/type error。

3. **关键流程记录**
   - **积分消费链路**：`ConsumeCreditsCard → use-credits hooks → consumeCreditsAction → CreditLedgerDomainService`，需要在 UI 层隐藏 Devtools 卡片并改善 `getUserCredits` 的异常处理；Domain 层 FIFO 扣减逻辑稳定。
   - **AI 内容分析**：`useWebContentAnalyzer → /api/analyze-content → analyzeWebContentWithCredits → handleAnalyzeContentRequest`，建议合并重复校验并确保 Upstash 配置可监控，否则速率限制将退化为本地 Map。

4. **报告结论摘要**
   - 总体架构符合“UI → Actions/API → Domain → Infra”分层；主要风险集中在边界承载层（上传入口、Devtools 组件、封禁绕过）。
   - 已完成上传 API 修复与封禁校验加固，并通过静态分析检测；其余整改（如 Devtools 隐藏、Upstash 配置监控）已在 issue 列表中待后续冲刺处理。

5. **后续建议**
   - 为 Devtools 组件添加编译期开关或 `process.env.NODE_ENV` 守卫，防止误入生产。
   - 在 CI 中加入 Upstash 配置校验脚本，避免速率限制 silently fallback。
   - 持续收敛 credits service 的对外 API，仅暴露必要函数并加强日志监控，防止其他地方再出现吞错。
   - **前端日志统一方案**（详述如下）：
     1. 新增 `src/lib/client-logger.ts`，暴露 `info/warn/error/debug` 等方法；内部根据 `process.env.NODE_ENV` 判断是否输出到 `console`，并预留扩展点（未来可接入 Sentry/LogRocket 等）。生产模式默认 no-op，以避免敏感信息泄露。
     2. 将 `logAnalyzerComponentError`、`logError` 等公共方法改为调用 `clientLogger`，替换 AI 模块中直接使用 `console` 的场景。其他常用 hook（如 `use-credits`, `useWebContentAnalyzer`）也改用 `clientLogger.debug` 记录调试信息。
     3. 逐步清理各组件中的 `console.*`：对需要保留的调试输出改用 `clientLogger.debug`，其余直接删除或改为 toast/日志。可按模块分批进行（先 AI/credits，再 auth/settings 等），避免一次性改动过大。
     4. 在 `.codex/plan` 或 README 中记录“前端禁止直接使用 console，统一通过 `clientLogger`”的约定，并在 Code Review 中执行。

> 当前进度：五个阶段均完成，详规与报告摘要如上；`/api/storage/upload` 加固、文档与配置同步已合并，静态分析通过。
